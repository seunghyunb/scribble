package fifth


/* 기존 자바 API에 람다를 활용하는 방법
     코틀린 람다를 자바 API에 사용해도 아무 문제가 없다.

     함수형 인터페이스, SAM 인터페이스(Single Abstract Method 단일 추상 메소드)
      함수형 인터페이스
       1개의 추상 메소드를 갖는 인터페이스를 말한다.
       Java8 부터 인터페이스는 기본 구현체를 포함한 Default Method 를 포함할 수 있다.
       여러개의 메소드가 있더라도 추상 메서드가 오직 하나면 함수형 인터페이스다.
       @FunctionalInterface 어노테이션은 해당 인터페이스가 함수형 인터페이스 조건에 맞는지 검사한다.
       https://bcp0109.tistory.com/313
      자바 API 에는 Runnable 이나 Callable 같은 함수형 인터페이스와 그런 함수형 인터페이스를 활용하는 메소드가 많다.
      코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다.

     자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다.
      따라서 코틀린에서 함수를 인자로 받는 함수는 함수형 인터페이스가 아니라 함수 타입을 사용해야 한다.

     함수형 인터페이스 타입을 인자로 요구하는 자바 메소드에 람다를 전달하는 경우 벌어지는 일
      컴파일러는 자동으로 무명 클래스와 인스턴스를 만들어준다. 이때 전달한 람다는 메소드 본문으로 사용된다.

     람다와 무명 객체의 차이
      객체를 명시적으로 선언하는 경우 메소드를 호출할 때마다 새로운 객체가 생성된다.
      람다는 주변 영역의 변수를 포획할 경우에만 매 호출마다 새로운 인스턴스가 생성된다.
       변수 포획을 하지 않았다면 전역 변수로 컴파일되어 단 하나의 인스턴스만 만들어서 이 인스턴스를 재사용한다.

     람다가 변수를 포획하면
      무명 클래스 안에 포획한 변수를 저장하는 필드가 생기며, 매 호출마다 그 무명 클래스의 인스턴스를 새로 만든다.
      하지만 포획하는 변수가 없는 람다에 대해서는 인스턴스가 하나만 생긴다.

     함수형 인터페이스를 받는 자바 메소드를 코틀린에서 호출할 때 쓰는 방식
      람다에 대해 무명 클래스를 만들고 그 클래스의 인스턴스를 만들어서 메소드에 넘긴다.

     컬렉션을 확장한 메소드에 람다를 넘기는 경우
      inline 으로 표시된 코틀린 함수에게 람다를 넘기면 아무런 무명 클래스도 만들어지지 않는다.
      대부분의 코틀린 확장 함수들은 inline 표시가 붙어있다.

   SAM 생성자
    람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.
    컴파일러가 자동으로 람다를 함수형 인터페이스로 바꾸지 못하는 경우 SAM 생성자를 사용할 수 있다.
    SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
    SAM 생성자는 함수형 인터페이스의 유일한 추상 메소드의 본문에 사용할 람다만 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.

   람다와 무명객체 안에서 this 가 가리키는 것.
    람다는 무명 객체와 달리 인스턴스 자신을 가리키는 this 가 없다.
     컴파일러 입장에서 보면 람다는 코드 블록일 뿐이고, 객체가 아니므로 객체처럼 람다를 참조할 수 없다.
     람다 안에서 this 는 람다를 둘러싸고 있는 클래스의 인스턴스를 가리킨다.
    무명 객체 안에서 this는 무명 객체 인스턴스를 가리킨다.


   수신 객체 지정 람다
    자바의 람다에는 없는 코틀린 람다의 독특한 기능이다.
    수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다.
    람다는 일반 함수와 비슷한 동작을 정의하는 하나의 방법이고, 수신 객체 지정 람다는 확장 함수와 비슷한 동작을 정의하는 하나의 방법이다.
    수신 객체 지정 람다는 DSL(Domain Specific Language 영역 특화 언어)을 만들 때 매우 유용한 도구다.

   with
    어떤 객체의 이름을 반복하지 않고도 그 객체에 대해 다양한 연산을 수행할 수 있다며 좋을 것이다. 다양한 언어가 이런 기능을 제공한다.
    코틀린은 라이브러리 함수 with 를 통해 제공한다.
    with 문은 언어가 제공하는 특별한 구문 처럼 보이지만 실제로는 파라미터가 2개 있는 함수다.
     람다를 괄호 밖으로 빼는 관례를 사용함에 따라 함수 호출이 언어가 제공하는 특별 구문처럼 보이게 한다.
    인자로 넘긴 객체의 클래스와 with를 사용하느 코드가 들어있는 클래스 안에 이름이 같음 메소드가 있는 경우 this 참조 앞에 레이블을 붙이면 호출하고 싶으 메소드를 명확하게 정할 수 있다.
     this@OuterClass.toString() 과 같이 사용하면 된다.
    with 가 반환하는 값은 람다 코드를 실행한 결과이며, 람다 본문의 마지막 식의 값이다.

   apply
    람다의 결과 대신 수신 객체가 필요한 경우 with 대신 apply 라이브러리 함수를 사용한다.
    거의 with와 같다. 유일한 차이는 apply 는 항상 자신에게 전달된 수신 객체를 반환한다는 점이다.
    확장 함수로 정의돼 있다. apply 의 수신 객체가 전달받은 람다의 수신 객체가 된다.
    apply 함수는 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우 유용하다.
     자바에서는 보통 별도의 Bulder 객체가 이런 역할을 담당한다.
      코틀린에서는 어떤 클래스가 정의돼 있는 라이브러리의 특별한 지원 없이도 그 클래스의 인스턴스에 대해 apply 를 활용할 수 있다.

   buildString
    StringBuilder 를 활용해 String 을 만드는 경우 사용할 수 있는 우아한 해법이다.

*/

fun createAllDoneRunnable(): Runnable {
    return object : Runnable {
        override fun run() {
            println("Done")
        }
    }
}

fun alphabet_237(): String {
    val stringBuilder = StringBuilder()

   return with(stringBuilder) { // 메소드를 호출하려는 수신 객체를 인자로 지정
        // 람다 안에서 this를 사용해 수신 객체에 접근할 수 있다.
        for (letter in 'A'..'Z')
            this.append(letter)

        // this 를 생략하고 프로퍼티나 메소드 이름만 사용해도 수신 객체의 멤버에 접근할 수 있다.
        append("\nNow I know the alphabet!")
       this.toString()  // 람다에서 값을 반환한다.
    }
}

fun alphabet_240() = StringBuilder().apply {
    for (letter in 'A'..'Z')
        append(letter)
    append("\nI know ~~~")
}.toString()



fun alphabet_239() = with(StringBuilder()) {
    for(letter in 'A'..'Z')
        append(letter)
    append("\n I know the alphabet~!")
    toString()
}

fun main() {

    val lambda = { println("End") }
    val s = object : Runnable {
        override fun run() {
        }
    }

    println(lambda.javaClass)
    println(s.javaClass)


}