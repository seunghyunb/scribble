package ninth

import java.awt.Point
import java.lang.IllegalArgumentException
import java.util.*
import kotlin.reflect.KClass

/*
    제네릭스를 더 깊이 다루면서 실체화한 타입 파라미터나 선언 지점 변성 등의 새로운 내용을 설명한다.
     실체화한 타입 파라미터를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행 시점에 알 수 있다.
      일반 클래스나 함수의 경우 타입 인자 정보가 실행 시점에 사라지기 때문에 이런 일이 불가능하다.
     선언 지점 변성을 사용하면 기저 타입은 같지만 타입 인자가 다른 두 제네릭 타입 Type<A> 와 Type<B> 가 있을 때 타입 인자 A 와 B의 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.
      기저 타입 : 원서에서는 base type 으로 객체지향의 기반 타입과 같은 용어를 사용한다. 하지만  List 와 List<String> 이 기반-파생 관계라고 보기는 어렵기에 제네릭 타입에서 타입 파라미터를 제외한 부분을 가리킬 때 기저 타입이라는 용어를 사용했다.
     사용 지점 변성은 같은 목표를 제네릭 타입 값을 사용하는 위치에서 파라미터 타입에 대한 제약을 표시하는 방식으로 달성한다.

    제네릭 타입 파라미터
     제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다.
     제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
     코틀린 컴파일러는 타입 인자를 추론할 수 있다.
      하지만 빈 리스트를 만든다면 추론할 인자가 없어 타입 인자를 명시해야 한다.

    제네릭 함수와 프로퍼티
     제네릭 함수를 호출할 때는 반드시 구체적인 타입으로 타입 인자를 넘겨야 한다.
     컬렉션을 다루는 라이브러리 함수는 대부분 제네릭 함수다.
     함수의 타입 파라미터 T 가 수신 객체와 반환 타입에 쓰인다.
     클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다.
     제네릭 확장 프로퍼티를 선언할 수 있다.
      일반 프로퍼티는 타입 파라미터를 가지지 못하고 확장 프로퍼티만 제네릭하게 만들 수 있다.
      클래스 프로퍼티에 여러 타입의 값을 저장할 수는 없으므로 제네릭한 일반 프로퍼티는 말이 안된다.
      일반 프로퍼티를 제네릭하게 정의하면 오류를 표시한다.
       ERROR: type parameter of a property must be used in its receiver type

    제네릭 클래스 선언
     자바와 마찬가지로 클래스 이름 뒤에 타입 파라미터를 넣은 꺾쇠 기호<> 를 붙이면 제네릭하게 만들 수 있다.
     클래스에 타입 파라미터를 붙이고 나면 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.
     제네릭 클래스 또는 제네릭 인터페이스를 확장 또는 구현하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다.
      이때 구체적인 타입을 넘길 수도 있고 타입 파라미터로 받은 타입을 넘길 수도 있다.

    타입 파라미터 제약 type parameter constraint
     클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능.
     어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한(upper bound)으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
     제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:) 을 표시하고 뒤에 상한 타입을 적으면 된다.
     타입 파라미터 T에 상한을 정하고 나면 T 타입의 값을 상한 타입의 값으로 취급할 수 있다.
     아주 드물지만 타입 파라미터에 둘 이상의 제약을 가해야 하는 경우도 있다.
     널이 될 수 없는 타입으로 파라미터를 한정하고 싶을 때 파라미터 제약을 자주쓴다.

    타입 파라미터를 널이 될 수 없는 타입으로 한정
     아무런 상한을 정하지 않은 타입 파라미터는 Any? 상한으로 정한 파라미터와 같다.
     항상 널이 될 수 없는 타입만 인자로 받으려면 Any 를 상한으로 사용한다.

    지금까지는 코틀린 제네릭스의 기초를 살펴봤다. 코틀린 제네릭스가 자바와 다른 점에 대해 보자.

    JVM의 제네릭스는 보통 타입 소거를 사용해 구현된다.
     실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다.

    실행 시점의 제네릭: 타입 검사와 캐스트
     자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
      이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.
     타입 소거로 인해 생기는 한계를 보자.
      타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.
      실행 시점에 List 인건 알 수 있으나 List<String> 인지는 알 수 없다.
     타입 소거는 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인 메모리 사용량이 줄어든다는 장점이 있다.
     인자를 알 수 없는 제네릭 타입을 표현할 때 스타프로젝션(*)을 사용한다. (9장에서 스타프로젝션에 대해 다룬다)
     타입파라미터가 2개 이상이라면 모든 타입 파라미터에 *를 포함시켜야 한다.
     코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행하게 허용할 정도로 똑똑하다.
     코틀린 컴파일러는 안전하지 못한 검사와 수행할 수 있는 검사를 알려주기 위해 최대한 노력한다.
      코틀린 컴파일러는 안전하지 못한 is 검사는 금지하고, 위험한 as 캐스팅은 경고를 출력한다.
      따라서 컴파일러 경고의 의미와 어떤 연산이 안전한지 알아야 한다.

    실체화한 타입 파라미터를 사용한 함수 선언
     코틀린 제네릭 타입 인자 정보는 실행 시점에 사라진다.
     인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.
     인라인 함수에서만 실체화한 타입 인자를 쓸 수 있는 이유
      컴파일러는 인라인 함수의 본문을 구현한 바이트 코드를 그 함수가 호출되는 모든 지점에 삽입한다.
       - 본문을 구현한 바이트 코드에는 구체적인 타입이 들어가게 된다.
      컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다.
       - 구체적인 타입을 가지고 구현된 본문이 삽입되어 있음.
      따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.
      타입 파라미터가 아니라 구체적인 타입을 사용하므로 만들어진 바이트코드는 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는다.
      자바 코드에서는 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다.
       자바에서는 inline 함수를 일반 함수처럼 호출한다.
      inline 함수로 성능을 좋게 하려면 함수의 크기를 계속 관찰해야 한다. 함수가 커치면 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.

    실체화한 타입 파라미터로 클래스 대신 참조
     java.lang.Class 타입 인자를 파라미터로 받는 API에 대한 코틀린 어댑터를 구축하는 경우 실체화한 타입 파라미터를 자주 사용한다.
     ServiceLoader는 어떤 추상 클래스나 인터페이스를 표현하는 java.lang.Class를 받아서 그 클래스나 인스턴스를 구현한 인스턴스를 반환한다.

    실체화한 타입 파라미터의 제약
     일부는 실체화의 개념으로 인해 생기는 제약이며, 나머지는 코틀린이 실체화를 구현하는 방식에 의해 생기는 제약으로 향후 완화될 가능성이 있다.
     실체화한 타입 파라미터를 사용할 수 있는 경우
      - 타입 검사와 캐스팅(is, !is, as, as?)
      - 코틀린 리플렉션 API(::class)
      - 코틀린 타입에 대응하는 java.lang.Class 얻기(::class.java)
      - 다른 함수를 호출할 때 타입 인자로 사용
     실체화한 타입 파라미터로 할 수 없는 일
      - 타입 파라미터 클래스의 인스턴스 생성하기
      - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
      - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
      - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

    변성 variance
     변성 개념은 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
   직접 제네릭 클래스나 함수를 정의하는 경우 변성을 꼭 이해해야 한다.
     변성을 잘 활용하면 사용에 불편하지 않으면서 타입 안전성을 보장하는 API를 만들 수 있다.

    클래스, 타입, 하위 타입
     타입과 클래스의 차이
      가장 단순한 경우
       제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다. (String 또는 String?)
       제네릭 클래스에서는 올바른 타입을 얻으려면 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
        List는 클래스지 타입이 아님.
        List<Int>, List<String> 은 타입이다.
     타입 사이의 관계를 논하기 위해 하위 타입이라는 개념을 잘 알아야 한다.
      A 타입의 값이 필요한 모든 장소에 B 타입의 값을 넣어도 아무 문제가 없다면 B 타입은 A 타입의 하위 타입이다. (Int 는 Number 의 하위 타입이다)
      상위 타입은 하위 타입과 반대다. A 타입은 B 타입의 상위 타입이다. (Number 는 Int 의 상위 타입이다)
     하위 타입이 왜 중요할까?
      컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.
      어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다.
      간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다. (Int 는 Number 의 하위 클래스)
      어떤 인터페이스를 구현하는 클래스의 타입은 그 인터페이스 타입의 하위 타입이다.(String 은 CharSequence 의 하위 타입)
      널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다. (A 타입은 A? 의 하위 타입이다)
     제네릭 타입을 인스턴스화하는데 타입 인자로 서로 다른 타입을 넣었을 때 인스턴스 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 무공변이라고 한다.
     코틀린의 List 인터페이스는 읽기 전용 클렉션을 표현한다. A가 B의 하위 타입이면 List<A> 는 List<B>의 하위 타입이다. 이런 클래스나 인터페이스를 공변적이라 말한다.

    공변성: 하위 타입 관계를 유지
     코틀린에서 제네릭 클래스가 타입 파라미적터에 대해 공변임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다.
     클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.
     타입 안전성을 보장하기 위해 공변적 파라미터는 항상 out 위치에만 있어야 한다.
      out 키워드는 T의 사용법을 제한하며 T로 인해 생기는 하위 타입 관계의 타입 안전성을 보장한다.
      이는 클래스가 T 타입의 값을 생산할 수는 있지만 T 타입의 값을 소비할 수는 없다는 뜻이다.
       T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치에 있다. 그 함수는 T 타입의 값을 생산한다.
       T가 함수의 파라미터 타입에 쓰인다면 T는 인 위치에 있다. 그런 함수는 T 타입의 값을 소비한다.
     out 키워드는 두 가지를 함께 의미한다.
      - 공변성 : 하위 타입 관계가 유지된다.
      - 사용제한 : T를 아웃 위치에서만 사용할 수 있다.(반환 타입위치에 쓰인다)
     생성자 파라미터는 인이나 아웃 어느 쪽도 아니다.
      타입 파라미터가 out이라 해도 그 타입을 여전히 생성자 파라미터 선언에 사용할 수 있다.
     변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 한다.
      생성자는 인스턴스를 생성한 뒤 나중에 호출할 수 있는 메소드가 아니므로 위험할 여지가 없다.
      하지만 val 이나 var 키워드를 생성자 파라미터에 적는다면 게터나 세터를 정의하는 것과 같으므로 읽기 전용 프로퍼티는 out 위치, 변경 가능 프로퍼티는 in, out 모두 해당한다.
      이런 규칙은 위부에서 볼 수 있는 (public, protected, internal) 클래스 API 에만 적용할 수 있다.
       비공개 메소드의 파라미터는 in 도 out 도 아니다.
      변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다.


    반공변성: 뒤집힌 하위 타입 관계
     클래스의 타입 파라미터가 in 위치에서만 쓰이는 경우에는 타입 파라미터의 하위 타입 관계와 제네릭 타입의 하위 타입 관계가 서로 역전된다.
     반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.
      예로 Comparator 인터페이스를 볼 수 있다.
       sortedWith 함수는 Comparator<String> 을 요구하지만 더 일반적인 타입을 비교할 수 있는 Comparator를 sortedWith에 넘기는 것은 안전하다.
       이는 Comparator<Any> 가 Comparator<String> 의 하위 타입인 관계가 성립한다.
        여기서 Any는 String의 상위 타입이다.
     in이라는 키워드는 in 이라는 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다.
     공변성의 경우와 마찬가지로 타입 파라미터의 사용을 제한함으로써 특정 하위 타입 관계에 도달할 수 있다.

    지금까지 클래스 정의에 변성을 직접 기술하면 클래스를 사용하는 모든 장소에서 변성이 적용된다는 점을 알 수 있다.
     자바는 이를 지원하지 않는다.대신 클래스를 사용하는 위치에서 와일드카드를 사용해 그때그때 변성을 지정해야 한다.

    사용 지점 변성: 타입이 언급되는 지점에서 변성 지정
     클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에서 변성 지정자가 영향을 끼치므로 편리하다.
      이런 방식을 선언 지점 변성이라 부른다.
      선언 지점 변성을 사용하면 변성 변경자를 단 한 번만 표시하고 클래스를 쓰는 쪽에서는 변성에 대해 신경을 쓸 필요가 없으므로 코드가 더 간결해진다.
     자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 한다.
      이런 방식을 사용 지점 변성이라 부른다.
     타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에서나 변성 변경자를 붙일 수 있다.
      이때 타입 프로젝션이 일어난다. 즉, 변성 변경자가 붙은 기저타입을 프로젝션을 한(제약을 가한) 타입으로 만든다.
       out인 경우 기저타입의 메소드 중에서 타입 파라미터(T)를 out 위치에서 사용하는 메소드만 호출할 수 있다.
       - 타입 프로젝션: 타입 파라미터를 사용하는 메소드만 사용가능하도록 제약이 걸린다.
     코틀린의 사용 지점 변성 선언은 자바의 한정 와일드카드와 똑같다.
     사용 지점 변성을 사용하면 타입 인자로 사용할 수 있는 타입의 범위가 넓어진다.

    스타 프로젝션: 타입 인자 대신 * 사용
     제네릭 타입 인자 정보가 없음을 표시하기 위해 스타 프로젝션을 사용한다.
     스타 프로젝션을 사용할 때는 값을 만들어내는 메소드만 호출할 수 있고 그 값의 타입에는 신경을 쓰지 말아야 한다.
     스타 프로젝션의 의미
      MutableList<*>는 MutableList<Any?>와 같지 않다.
       MutableList<Any?>는 모든 타입의 원소를 담을 수 있는 리스트다.
       MutableList<*>는 어떤 정해진 구체적인 타입의 원소만을 담는 리스트지만 그 원소의 타입을 정확히 모른다는 사실을 표현한다.
*/

// 리스트의 마지막 원소 바로 앞에 있는 원소를 반환하는 확장 프로퍼티
val <T> List<T>.penultimate: T
    get() = get(lastIndex - 1)


interface List_388<T> {
    operator fun get(index: Int): T
}

class StringList_389 : List_388<String> {
    override fun get(index: Int): String {
        return javaClass.name
    }
}


// ArrayList_389 에서 정의한 K 와 List_388 에서 정의한 T 는 다르다.
class ArrayList_389<K> : List_388<K> { // List_388의 타입 인자로 ArrayList_389 의 파라미터 타입을 지정한 것이다.
    override fun get(index: Int): K {
        return get(index)
    }
}

// 클래스가 자기 자신을 타입 인자로 참조할 수도 있다. 예로 Comparable 이 있다.
class String_389 : Comparable<String_389> { // String_389 본인을 Comparable의 타입 인자로 넘겼다.
    override fun compareTo(other: String_389): Int {
        return 0
    }
}

// Number 타입으로 타입 상한, Number 의 하위 타입도 가능.
fun <T : Number> List<T>.sum_390(): T {
    val result = sumBy { it.toInt() }
    return result as T
}

fun printSum(c: Collection<*>) { // 2개 이상의 타입 파라미터가 가능하다. 스타 프로젝션을 사용함.
    // Unchecked cast 경고를 띄운다.
    // 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅은항상 성공한다.
    // 컴파일러는 단순히 경고만 하고 컴파일을 진행하므로 실행 시점에 잘못된 타입이 들어있으면 예외가 발생한다.
    /*
     printSum 에 문자열 리스트를 넘기는 경우를 보자.
     어떤 값이 List<Int>인지 검사할 수 없으므로 IllegalArgumentException 이 발생하지는 않는다.
     따라서 as? 캐스트가 성공하고 sum 이 실행되는 도중에 예외가 발생한다.
    */

    val intList = c as? List<Int>
            ?: throw IllegalArgumentException("List is expected")

    println(intList.sum()) // sum()은 Number 타입의 값을 리스트에서 가져와서 서로 더하려고 시도한다.
}

fun printSum2(c: Collection<Int>) { // Int 라는 타입 정보가 주어져 있다.
    // 타입 정보가 주어져 있으므로 is 검사가 가능하다.
    if (c is List<Int>) { // 이 검사는 올바르다.
        println(c.sum())
    }
}


// fun <T> isA(value: Any) = value is T // cannot check for instance of erased type: T

// 실체화한 타입 파라미터
// reified 키워드는 이 타입 파라미터가 실행 시점에 지워지지 않음을 표시한다.
inline fun <reified T> isA(value: Any) = value is T


inline fun <reified T> loadService() {
    // 일반 클래스에 사용할 수 있는 ::class.java. 구문을 이 경우도 사용 가능하다.
    // 이를 통해 타입 파라미터로 지정된 클래스에 따른 java.lang.Class 를 얻을 수 있고, 얻은 클래스 참조를 보통 때와 마찬가지로 사용할 수 있다.
    ServiceLoader.load(T::class.java) // T::class 로 타입 파라미터의 클래스를 가져온다.
}

fun test(i: Int) {
    val n: Number = i // Int 가 Number 의 하위 타입이어서 컴파일된다.
    fun f(s: String) { /*...*/}
    // f(i) // Int 가 String의 하위 타입이 아니라서 컴파일되지 않는다
}

fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {
    for (item in source) {  // 여기서 source 는 get 이 호출되니까 T가 반환 타입으로 사용되었음
        destination.add(item)
    }
}

/*
    안전하지 못한 모든 로직을 클래스 내부에 감춤으로써 외부에서 그 부분을 잘못 사용하지 않음을 보장할 수 있다.
    안전하지 못한 코드를 별도로 분리하면 그 코드를 잘못 사용하지 못하게 방지할 수 잇고, 안전하게 컨테이너를 사용하게 만들 수 있다.
*/

interface FieldValidator<in T> { // T 에 대해 반공변
    fun validate(input: T): Boolean  // in 위치에서만 사용. 값을 소비한다.
}

object Validators {
    private val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    fun <T: Any> registerValidator(
            kClass: KClass<T>,
            fieldValidator: FieldValidator<T>
    ) {
        validators[kClass] = fieldValidator
    }

    @Suppress("UNCHECKED_CAST")
    operator fun <T:Any> get (kClass: KClass<T>): FieldValidator<T> {
        return validators[kClass] as? FieldValidator<T>
                ?: throw IllegalArgumentException("No validator for ${kClass.simpleName}")
    }
}

fun main() {
    val letters = ('a'..'z').toList()
    println(letters.slice<Char>(0..2)) // 타입 인자를 명시적으로 지정.
    println(letters.slice(3..7)) // 코틀린 컴파일러는 T 가 Char 라는걸 추론한다.
    println(letters.penultimate)

    println(listOf(1, 2, 3, 4).sum_390())
    println(listOf(1.0, 2.0, 3.0, 4.0).sum_390())

    /*
        실행 시점에 list1 이나 list2가 어떤 타입의 리스트로 선언됐는지 알 수 없다. 각 객체는 단지 List 일 뿐이다.
        컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만 실행 시점에 그 둘은 완전히 같은 타입의 객체다.
         보통은 List<String> 에 문자열만 들어있다고 가정할 수 있는데, 이는 컴파일러가 타입인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해주기 때문이다.
         하지만 속이려면 속일 수 있으나 폼이 많이 든다.
    */
    val list1: List<String> = listOf("a", "b")
    val list2: List<Int> = listOf(1, 2, 3)
    /*
    // 타입 소거로 인해 실행 시점에 타입 인자가 지워져 is 검사가 불가능하다.
    if (list2 is List<String>) {
        println("list1 is List<String>")
    }
    */

    printSum(listOf(1, 2, 3, 4))
    printSum(listOf(1L, 2L, 3L, 40L))
//    printSum(listOf("1", "2", "3"))

    /*
        실체화한 타입 파라미터를 활용하는 가장 간단한 예제 중 하나는 표준 라이브러리 함수인 filterIsInstance 다.
        이 함수는 인자로 받은 컬렉션의 원소 중에서 타입 인자로 지정한 클래스의 인스턴스만을 모아서 만든 리스트를 반환한다.
        filterIsInstance 는 람다를 인자로 받지 않지만 inline 함수로 선언되었다.
         성능 향상이 아닌 실체화한 타입 파라미터를 사용하기 위한 목적이다.
    */
    val items = listOf("one", 2, "three")
    println(items.filterIsInstance<String>())

    /*
        표준 자바 API인 ServiceLoader
        ::class.java 구문은 코틀린 클래스에 대응하는 java.lang.Class 참조를 얻는 방법이다.
        Service::class.java 코드는 Service.class 와 완전히 같은 코드다. (이에 대해 10.2절 리플렉션에 대해 설명할 때 자세히 다룬다)
    */
    val serviceImpl = loadService<Point>()

    // 타입 파라미터를 out 위치에서 사용하는 메소드만 호출 가능하다.
    val list: MutableList<out Int> = mutableListOf(1, 2, 3, 4, 5)
    println(list[0])

}
