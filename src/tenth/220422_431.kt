package tenth

/*
    어떤 함수를 호출하려면 그 함수가 정의된 클래스의 이름과 함수 이름, 파라미터 이름 등을 알아야만 했다.
    애노테이션과 리플렉션을 사용하면 그런 제약을 벗어나서 미리 알지 못하는 임의의 클래스를 다룰 수 있다.
    애노테이션을 사용하면 라이브러리가 요구하는 의미를 클래스에게 부여할 수 있다.
    리플렉션을 사용하면 실행 시점에 컴파일러 내부 구조를 분석할 수 있다.

    애노테이션을 적용하기는 쉽다. 하지만 애노테이션을 직접 만들기는 어렵고, 애노테이션을 처리하는 코드를 작성하기는 더 어렵다.
    애노테이션을 사용하는 문법은 자바와 똑같지만 애노테이션을 선언할 때 사용하는 문법은 자바와 약간 다르다.
    메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해준다.
    애노테이션을 적용하려면 적용하려는 대상 앞에 애노테이션을 붙이면 된다.
     @과 애노테이션 이름으로 이뤄진다.
    자바와 코틀린에서 @Deprecated의 의미는 같다. 하지만 코틀린에서는 replaceWith 파라미터를 통해 옛 버전을 대신할 수 있는 패턴을 제시할 수 있고, API 사용자는 그 패턴을 보고 지원이 종료될 API 기능을 더 쉽게 새 버전으로 포팅할 수 있다.
     @Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)")) // 사용을 금지하는 메세지와 대체할 패턴을 지정
     fun remove(index: Int) {...}
      이런 remove 선언이 있다면 인텔리J 아이디어는 remove를 호출하는 코드에 대해 경고 메시지("Use removeAt(index) instead")를 표시해 줄 뿐 아니라 새로운 API 버전에 맞는 퀵 픽스도 제시해준다.
    애노테이션에 인자를 넘길 때는 괄호 안에 인자를 넣는다.
    애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스 그리고 지금까지 말한 요소들로 이뤄진 배열이 들어갈 수 있다.
    애노테이션 인자를 지정하는 문법은 자바와 조금 다르다.
     - 클래스를 애노테이션 인자로 지정할 때는 ::class 를 클래스 이름 뒤에 넣어야 한다. (MyClass::class)
     - 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션 이름 앞에 @를 넣지 않아야 한다. 위에서 본 RepalceWith는 애노테이션이지만 인자로 들어가 @를 붙이지 않았다.
     - 배열을 인자로 지정하려면 @RequestMapping(path = arrayOf("/foo", "/bar")) 처럼 arrayOf 함수를 사용한다.
       자바에서 선언한 애노테이션 클래스를 사용한다면 value라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환된다.
       그런 경우에는 @JavaAnnotationWithArrayValue("abc", "foo", "bar")처럼 arrayOf 함수를 쓰지 않아도 된다.
    애노테이션 인자를 컴파일 시점에 알 수 있어야 한다. 따라서 임의의 프로퍼티를 인자로 지정할 수는 없다.
    프로퍼티를 애노테이션 인자로 사용하려면 그 앞에 const 변경자를 붙여야 한다. 컴파일러는 const 가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.
     const가 붙은 프로퍼티는 파일의 맨 위나 object 안에 선언 해야 하며, 원시 타입이나 String으로 초기화해야만 한다.
     일반 프로퍼티를


    리플렉션 API의 일반 구조는 자바와 같지만 세부 사항에서 약간 차이가 있다.

*/
fun main() {

}
