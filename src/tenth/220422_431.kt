package tenth

/*
    애노테이션과 리플렉션
     애노테이션을 사용하면 라이브러리가 요구하는 의미를 클래스에게 부여할 수 있다.
     애노테이션을 선언할 때 사용하는 문법은 자바와 약간 다르다.

     리플렉션을 사용하면 실행 시점에 컴파일러 내부 구조를 분석할 수 있다.
     리플렉션 API의 일반 구조는 자바와 같지만 세부 사항에서 약간 차이가 있다.

    애노테이션과 리플렉션의 사용법을 보여주는 예제로 JSON 직렬화와 역직렬화 라이브러리인 JKid 를 구현한다.
     실행시점에 코틀린 객체의 프로퍼티를 읽거나 JSON 파일에서 읽은 데이터를 코틀린 객체로 만들기 위해 리플렉션을 사용한다.
     애노테이션을 통해 제이키드 라이브러리가 클래스와 프로퍼티를 직렬화하고 역직렬화하는 방식을 변경한다.

    애노테이션
     메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해준다.

    애노테이션 적용
     애노테이션은 @과 애노테이션 이름으로 이뤄진다.
     애노테이션을 적용하려면 적용하려는 대상 앞에 애노테이션을 붙이면 된다.

     @Deprecated 애노테이션
      코틀린에서는 replaceWith 파라미터를 통해 옛 버전을 대신할 수 있는 패턴을 제시할 수 있다.

     애노테이션에 인자를 넘길 때는 괄호 안에 인자를 넣는다.
      인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 지금까지 말한 요소로 이뤄진 배열이 들어갈 수 있다.
      애노테이션 인자를 컴파일 시점에 알 수 있어야 한다.
       따라서 임의의 프로퍼티를 인자로 지정할 수 없다.
       프로퍼티를 애노테이션 인자로 사용하려면 그 앞에 const 변경자를 붙여야 한다. (일반 프로퍼티는 오류가 발생한다)
        컴파일러는 const가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.
         const가 붙은 파라미터는 파일의 맨 위나 object 안에 선언해야 하며, 원시 타입이나 String으로 초기화해야만 한다.

     애노테이션 인자를 지정하는 문법
      애노테이션 인자를 지정하는 문법은 자바와 약간 다르다.
      - 클래스를 애노테이션 인자로 지정할 때는 클래스 이름 뒤에 ::class 를 넣어야 한다. (클래스 참조)
      - 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션 이름 앞에 @를 붙이지 않는다.
      - 배열을 인자로 지정하려면 arrayOf 함수를 사용한다.
         자바에서 선언한 애노테이션 클래스를 사용한다면 value 라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환된다.
         따라서 그런 경우 @JavaAnnotationWithArrayValue("abc", "foo", "bar") 처럼 arrayOf 함수를 쓰지 않아도 된다.


    애노테이션 대상
     사용 지점 대상(use-site target)은 @ 기호와 애노테이션 이름 사이에 붙으며, 애노테이션 이름과는 콜론(:)으로 분리된다.
      ex) @get:Rule (get <- 사용지점 대상 / Rule <- 애노테이션 이름) , 이 애노테이션 사용하는 예를 보자.
       제이유닛에서는 각 테스트 메소드 앞에 그 메소드를 실행하기 위한 규칙을 지정할 수 있다.
       규칙을 지정하려면 공개 필드나 메소드 앞에 @Rule 을 붙여야 한다.
       @Rule 은 공개 필드에 적용되지만 코틀린의 필드는 기본적으로 비공개이기 때문에 예외가 생긴다. 정확한 대상에 적용하려면 @get:Rule 을 사용해야한다.(게터에 애노테이션을 붙임)
     프로퍼티에 자바에 선언된 애노테이션을 붙이는 경우 기본적으로 필드에 그 애노테이션이 붙는다.
     코틀린으로 애노테이션을 선언하면 프로퍼티에 직접 적용할 수 있는 애노테이션을 만들 수 있다.
      사용 지점 대상을 지원하는 대상 목록
       - property 프로퍼티 전체, 자바에서 선언된 애노테이션에는 이 사용 지점 대상을 사용할 수 없다.
       - field 프로퍼티에 의해 생성되는 필드
       - get 프로퍼티 게터
       - set 프로퍼티 세터
       - receiver 확장 함수나 프로퍼티의 수신 객체 파라미터


*/
fun main() {

}
