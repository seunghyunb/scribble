
/*
    코틀린의 타입 시스템
     자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는데 도움이 되는 몇가지 특성을 새로 제공한다.
      널이 될 수 있는 타입과 읽기 전용 컬렉션이 있다.
      또한 코틀린은 자바 타입 시스템에서 불필요하거나 문제가 되던 부분을 제거했다.
       배열 지원이 그런 예에 속한다.

    널 가능성 Nullablility
     널 가능성은 NullPointerException(NPE) 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
     코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 하나 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.
     널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 컴파일 시 미리 감ㅈ미해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

    널이 될 수 있는 타입
     널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null 을 허용하게 만드는 방법이다.
     기본적으로 모든 타입은 널이 될 수 없는 타입이다. 하지만 타입 뒤에 ? 를 붙이면 널이 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.
     널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.
      예를 들어
       널이 될 수 있는 변수에 대해 변수.메소드() 처럼 메소드를 직접 호출할 수는 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입 변수에 대입할 수 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
     그렇다면 널이 될 수 있는 타입으로 뭘 할 수 있을까?
      가장 중요한 일은 null 과 비교하는 것이다.
       null 과 비교하고 나면 컴파일러는 그 사실을 기억하고 null 이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입틔 값처럼 사용할 수 있다.


    타입의 의미
     타입은 분류(classification)로 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

    NullPointerException 오류를 다루는 방법
     자바에도 NPE 문제를 해결하는데 도움을 주는 도구가 있다.
      @Nullable 이나 @NotNull 애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시한다.
      하지만 자바 컴파일 절차의 일부가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다.
     이 문제를 해결하는 다른 방법은 null 값을 코드에서 절대로 쓰지 않는 것이다.
      null 대신 자바 8에 도입된 Optional 타입 등의 null 을 감싸는 특별한 래퍼 타입을 활용할 수 있다.
       Optional 은 어떤 값이 정의되거나 정의되지 않을 수 있음을 표시하는 타입이다.
       이런 해법에는 몇가지 단점이 있다.
        코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 선응이 저하되며 전체 에코 시스템에서 일관성있게 활용하기 어렵다.
        Optional 을 사용하더라도 JDK 메소드나 안드로이드 프레임워크, 다른 서드파티 라이브러리 등에서 반환되는 null을 처리해야 한다.

    코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.
     실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
     널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
     모든 검사는 컴파일 시점에 수행된다. 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는데 별도의 실행 시점 부가 비용이 들지 않는다.

    널 가능성을 다루기 위해 사용할 수 있는 도구가 if 검사만 있을까?
     그렇지 않다. 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

    안전한 호출 연산자 ?.
     코틀린이 제공하는 가장 유용한 도구 중 하나가 안전한 호출 연산자인 ?. 이다.
     ?. 은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
      호출하려는 값이
       null 이 아니면 일반 메소드 호출처럼 동작한다.
       null 이면 이 호출을 무시하고 null 이 결과값이 된다.
     안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 사실을 기억.
     프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

    엘비스 연산자 ?:
     코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다.
     엘비스 연산자 ?: 는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다.
      좌항 값이
       null 이 아니면 좌항 값을 결과로 한다.
       null 이면 우항 값을 결과로 한다.
     엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비하는 값을 지정하는 경우도 많다.
     코틀린에서는 return 이나 throw 등의 연산도 식이다.
      따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.
       이런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.
       이런 패턴은 함수의 전제 조건(precondition)을 검사하는 경우 특히 유용하다.

     안전한 캐스트 as?
      타입 캐스트시 as 로 지정한 타입으로 바꿀 수 없으면 ClassCastException 이 발생한다.
      as? 연산자는 타입 캐스트시
       대상 타입으로 변환할 수 있으면 캐스트한다.
       대상 타입으로 변환할 수 없으면 null을 반환한다.
      안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

    널 아님 단언 !!
     널 아님 단언(not-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구다.
     !!를 사용하면 어떤 값이든 강제로 널이 될 수 없는 타입으로 바꿀 수 있다.
      실제 널에 대해 !!를 적용하면 NPE 가 발생한다.
     !!는 컴파일러에게 "나는 이 값이 null 이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다" 라고 말하는 것이다.
     !!를 한줄에 여러번 사용하는 일을 피하라.
      !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄이었는지에 대한 정보는 들어있으나 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

    널이 될 수 있는 타입의 값을 널이 아닌 값만 인자로 받는 함수에 넘기려면 어떻게 해야할까?
     그런 호출은 안전하지 않기 때문에 허용하지 않는다.
     코틀린 언어는 이런 경우 특별한 지원을 제공하지 않지만 표준 라이브러리에 도움이 될 수 있는 함수가 있다.
      그 함수는 let 이다.

    let
     let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.
     let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 될 수 없는 값만 인자로 받는 함수에 넘기는 경우다.
     자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
     안전한 호출 구문과 같이 사용해 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에게 전달할 수 있다.
     foo?.let { }
      foo 가 널이 아니면 람다를 실행한다. 이때 람다 안에서 it 은 foo 객체가 된다.
      foo 가 널이면 아무일도 일어나지 않는다.

    나중에 초기화할 프로퍼티
     val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다.
     코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.
      프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 초기화해야 한다.
      초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수밖에 없다.
       하지만 널이 될 수 있는 타입을 사용하면 프로퍼티 접근에 널 검사를 넣거나 !! 연산자를 써야 한다.
     이를 해결하기 위해 프로퍼티에 lateinit 을 써서 나중에 초기화할 수 있다.
      나중에 초기화하는 프로퍼티는 항상 var 여야 한다.
      나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다.

    널이 될 수 있는 타입 확장
     널이 될 수 있는 타입에 대한 확장 함수를 정의하면 널이 될 수 있는 값에 대해 안전한 호출 연산 없이 확장 함수를 호출할 수 있다.
      널이 될 수 있는 타입에 대한 확장 함수 내부에서 this 는 널이 될 수 있어 명시적으로 널 여부를 검사해야 한다.
       자바에서는 메소드 안의 this 는 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다.
        자바에서는 수신 객체가 널이었다면 NPE 가 발생해 메소드 안으로 들어가지를 못한다. 따라서 정상 실행됐다면 그 메소드 안에서 this 는 항상 널이 아니게 된다.
      let 함수도 널이 될 수 있는 값에 대해 호출할 수 있지만 let 은 this 가 널인지 검사하지 않는다. 따라서 널인지 검사하고 싶다면 안전한 호출 연산자를 같이 사용해야 한다.

    확장 함수를 정의할 때
     널이 될 수 있는 타입에 대해 정의할지 여부를 고민할 필요가 있다.
      처음에는 널이 될 수 없는 타입에 대한 확장 함수를 정의하라.
      나중에 널이 될 수 있는 타입에 대해 그 함수를 호출했다는 사실을 깨닫는다면 그 함수 안에서 널을 제대로 처리하기만 해주면 된다.
      확장 함수를 통해 널 검사를 함수 안으로 옮길 수 있다.

    타입 파라미터의 널 가능성
     코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
      따라서 타입 파라미터 T 를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T 가 널이 될 수 있는 타입이다.
      타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외다.
     타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한(upper bound)을 지정해야 한다.
      fun <T:Any> printHashCode(t: T) { ... } 이렇게 T:Any 이렇게 작성한 것을 타입 상한이라 하며 타입 파라미터가 널이 될 수없는 Any 타입만을 받도록 지정한다.

    플랫폼 타입
     코틀린은 애노테이션이 붙은 자바 타입을 애노테이션에 따라 널이 될 수 있는 타입이나 널이 될 수 없는 타입으로 취급한다.
      JSR-305 표준, 안드로이드, 젯브레인스 도구들이 지원하는 애노테이션 등이 코틀린이 이해할 수 있는 널 가능성 애노테이션들이다.
      이런 널 가능성 애노테이션이 소스 코드에 없는 경우 자바의 타입은 플랫폼 타입이 된다.
     플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
     널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.
     이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.
     컴파일러는 모든 연산을 허용한다.
      코틀린은 보통 널이 될 수 없는 타입에 널 검사를 하면 경고를 표시해주지만 플랫폼 타입의 값에 널 검사를 중복 수행해도 아무 경고를 표시하지 않는다.
     모든 자바 타입을 널이 될 수 있는 타입으로 다루면 널 검사 비용이 너무 커지게 되어 플랫폼 타입이 도입됐다.
     코틀린에서 플랫폼 타입을 선언할 수는 없다. 자바 코드에서 가져온 타입만 플랫폼 타입이 된다.
      IDE 나 컴파일러 오류 메시지에서는 플랫폼 타입을 볼 수 있다.
     플랫폼 타입의 표기는 타입! 로 표기한다.


    코틀린과 자바를 혼합한 클래스 계층을 선언할 때 빠지기 쉬운 함정
    상속
     코틀린에서 자바 메소드를 오버라이드할 때 메소드의 파라미터와 반환 타입의 널 여부를 결정해야한다.
      자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.

    널 가능성 관련 지식은 코틀린이 자바의 박스 타입을 처리하는 방법을 이해할 때 중요한 역할을 한다.

    코틀린의 원시 타입
     자바는 원시 타입과 참조 타입을 구분한다.
      원시 타입의 변수에는 값이 직접 들어간다.
       원시 타입의 값은 결코 널이 될 수 없다.
      참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.

     코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.
      코틀린은 항상 객체로 표현하는 것일까? 그렇지 않다.
      실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.
       대부분의 경우 변수, 프로퍼티, 파라미터, 반환 타입 등 코틀린의 Int 타입은 자바 int 타입으로 컴파일 된다.
        이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우 뿐이다.

    널이 될 수 있는 원시 타입
     널 참조는 자바의 참조 타입 변수에만 대입할 수 있으므로, 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 자바의 래퍼 타입으로 컴파일 된다.
     제네릭 클래스의 타입인자로 원시타입을 넘기면 그 타입에 대한 박스타입을 사용한다.
      JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다.

    숫자 변환
     코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다.
     코틀린 한 타입의 숫자를 다른 타입의 숫자로 변환하지 않는다.
      원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.
     코틀린은 모든 원시 타입에 대한 변환 함수를 제공한다.
      코틀린은 개발자의 혼란을 피하기 위해 타입 변환을 명시하기로 결정했다.
      코드에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.
     숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다.
      숫자 리터럴을 타입이 알려진 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.
     산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드 돼 있다.
     코틀린 산술 연산자에서도 자바와 똑같이 숫자 연산시 값 넘침(overflow)이 발생할 수 있다.
      값 넘침을 검사하느라 추가 비용을 들이지 않는다.

    최상위 타입 Any, Any?
     자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.
     원시 타입 값을 Any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다.
     내부에서 Any 타입은 java.lang.Object 에 대응한다.
      자바에서 Object 를 인자로 받거나 반환하면 코틀린에서는 Any 타입으로 취급한다(정확히는 플랫폼 타입 Any!).
     모든 코틀린 클래스에는 toString, equals, hashCode 라는 세 메소드가 들어있다.
      java.lang.Object 에 있는 다른 메소드 wait, notify 등은 Any에서 사용할 수 없다.
      따라서 그런 메소드를 호출하고 싶다면 java.lang.Object 타입으로 값을 캐스팅해야한다.

    Unit 타입: 코틀린의 void
     코틀린의 Unit 타입은 자바 void 와 같은 기능을 한다.
      코틀린 함수의 반환 타입이 Unit 이고 그 함수가 제네릭 함수를 오버라이드하지 않는다면 그 함수는 내부에서 자바 void 함수로 컴파일된다.
     대부분의 경우 void 와 Unit 의 차이를 알기는 어렵다. 다른 점은 무엇일까?
      Unit은 모든 기능을 갖는 일반적인 타입이며, void 와 달리 Unit 을 타입 인자로 쓸 수 있다.
      Unit 타입에 속한 값은 단 하나 뿐이며 이름도 Unit 이다.
      Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다.
      이 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 유용하다.
     코틀린에서 Void 가 아니라 Unit 이란 이름을 골랐을까?
      함수형 프로그래밍에서 전통적으로 Unit은 '단 하나의 인스턴스만 갖는 타입'을 의미해 왔고 바로 그 유일한 인스턴스의 유무가 자바 void 와 코틀린 Unit 을 구분하는 가장 큰 차이다.

    Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.
     결코 성공적으로 값을 돌려주는 일이 없으므로 '반환 값'이라는 개념 자체가 의미 없는 함수가 일부 존재한다.
      예를 들어 테스트 라이브러리들은 fail 이라는 함수를 제공하는 경우가 많다.
       fail 은 특별한 메시지가 들어있는 예외를 던져서 현재 테스트를 실패시킨다.
     Nothing 타입은 아무 값도 포함하지 않는다. 따라서 함수의 반환 타입이나 반환 타입으로 쓰일 파라미터로만 쓸 수 있다.
      Nothing 타입의 변수를 선언해도 값을 가질 수 없어 의미가 없다.
     Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수 있다.
      이런 방식은 타입 시스템에서 Nothing 이 얼마나 유용한지 보여준다.

    널 가능성과 컬렉션
     filterNotNull: 널이 될 수 있는 값으로 이뤄진 컬렉션에서 널 값을 걸러낼 때 사용 가능한 함수.

    읽기 전용과 변경 가능한 컬렉션
     코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나
      코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다.
     kotlin.collections.Collection 인터페이스를 사용하면 컬렉션 안의 원소에 대해 이터레이션하고, 컬렉션의 크기를 얻고, 어떤 값이 컬렉션 안에 들어있는지 검사하고, 컬렉션에서 데이터를 ㅣㅇㄺ는 여러 다른 연산을 수행할 수 있다.
      하지만 Collection 인터페이스에는 원소를 추가하거나 제거하는 메소드가 없다.
     컬렉션의 데이터를 수정하려면 kotlin.collections.MutableCollection 인터페이스를 사용한다.
      MutableCollection 인터페이스는 Collection 을 확장하면서 원소를 추가하거나, 삭제하거나, 컬렉션 안의 원소를 모두 지우는 등의 메소드를 더 제공한다.
     읽기 전용과 변경 가능한 컬렉션을 구분하는 이유는 프로그램에서 데이터에 어떤 일이 벌어지는지를 더 쉽게 이해하기 위함이다.
     컬렉션 인터페이스를 사용할 때 항상 염두에 둬야 할 핵심은 읽기 전용 컬렉션이라고 해서 꼭 변경 불가능한 컬렉션일 필요는 없다는 점이다.
      하나의 컬렉션 객체를 읽기 전용 컬렉션 타입으로 혹은 변경 가능한 컬렉션 타입으로 참조할 수 있다.
       그래서 사용 도중에 컬렉션의 내용이 변경 될 수 있으니 읽기 전용 컬렉션이 항상 스레드 안전하지 않다는 점을 명심해야 한다.

    코틀린 컬렉션과 자바
     자바 메소드를 호출하되 컬렉션을 인자로 넘겨야 한다면 추가 작업 없이 직접 컬렉션을 넘기면 된다.
      자바는 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용 Collection 으로 선언된 객체라도 자바 코드에서는 객체의 내용을 변경할 수 있다.
      코틀린 컴파일러는 자바 코드가 컬렉션에 대해 어떤 일을 하는지 완전히 분석할 수 없어 이를 막을 수 없다.
       이런 함정은 널이 아닌 원소로 이뤄진 컬렉션 타입에서도 발생한다.
       따라서 컬렉션을 자바 코드에 넘길 때는 특별히 주의를 기울여야 하며, 코틀린 쪽 타입이 적절히 자바 쪽에서 컬렉션에게 가할 수 있는 변경의 내용을 반영하게 해야 한다.

    컬렉션을 플랫폼 타입으로 다루기
     자바 쪽에서 선언언한 컬렉션 타입의 변수를 코틀린에서는 플랫폼 타입으로 본다.
     플랫폼 타입인 컬렉션은 기본적으로 변경 가능성에 대해 알 수 없다.

    객체의 배열과 원시 타입의 배열
     코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소 타입은 타입 파라미터에 의해 정해진다.
     배열을 인자로 받는 자바 함수를 호출하거나 vararg 파라미터를 받는 코틀린 함수를 호출하기 위해 가장 자주 배열을 만든다.
     데이터가 이미 컬렉션에 들어 있다면 컬렉션을 배열로 변환해야한다.
      toTypedArray 메소드를 사용하면 쉽게 컬렉션을 배열로 바꿀 수 있다.
     배열 타입의 타입 인자도 항상 객체 타입이 된다.
     코틀린은 원시 타입의 배열을 포현하는 별도 클래스를 각 원시 타입마다 하나씩 제공한다.
      IntArray, ByteArray 등은 자바 원시 타입 배열인 int[], byte[] 등으로 컴파일된다.
     코틀린 표준 라이브러리는 배열 기본 연산에 더해 컬렉션에 사용할 수 있는 모든 확장 함수를 배열에도 제공한다.
      filter, map 등 을 배열에 적용해도 잘 작동한다. 다만 이런 함수가 반환하는 값은 배열이 아니라 리스트라는 점에 유의해야 한다.


*/
/*
    검색
     1. 자바8 Optional 타입
     2. 의존 관게 주입 (DI)
     3. 동적 디스패치, 정적 디스패치
      디스패치
       프로그램이 어떤 메소드를 호출할 것인가를 결정하여 그것을 실행하는 과정을 말한다.
      정적 디스패치
       컴파일 시점에 컴파일러가 어떤 클래스의 메소드를 실행해야하는지 알고 바이트코드로 남는다.
      동적 디스패치
       컴파일 시점에선 어떤 메소드를 호출하는지 모르고, 추상 타입의 메소드를 호출하는 것만 알고 있다.
       런타임 시점에 할당된 객체의 타입을 보고 메소드를 실행함.
    4. 명령형 프로그래밍 과 함수형 프로그래밍
    5. 값 복사 와 참조 복사
*/
package sixth

import fifth.Person_212


fun notNullMethod(s: String) = "this is not null"

fun premetiveTypeCast(l: Long) = println(l)

class OverrdieJava: Java220325_272() {
    // null 이 불가능한 String 파라미터로 오버라이드함.
    override fun process(value: String) {}
}

fun showProgress_274(progress: Int) {
    // coerceIn 은 지정된 범위내에 값이 들어있는지 확인하는 표준 라이브러리 함수다.
    val percent = progress.coerceIn(0, 100)
    println("We're $percent% done!")
}

// 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 유용하다.
interface Processor<T> {
    fun process(): T // 어떤 값을 반환하라고 요구한다. Unit 타입도 Unit 값을 제공하기 때문에 Unit 값을 반환하는데 아무 문제가 없다.
}

class NoReulstProcessor: Processor<Unit> {
    override fun process() { // Unit을 반환하지만 타입을 지정할 필요가 없다.
        // return 을 명시할 필요가 없다. 컴파일러가 묵시적으로 return Unit 을 넣어준다.
    }
    /*
        이 코드가 디컴파일 됐을 때는 작성한 코드의 형태가 많이 바뀌게 된다.
         process()는 엄연히 Unit 타입의 값을 "반환" 하고 있다. return Unit.INTANCE
        디컴파일 했을 때 process()는 public void process() 와 public Object process() 두 개의 메소드가 만들어진다.
         이때 public Object process() 의 반환 값은 Unit 이다.
         Unit 값을 반환하는 메소드 1개와 아무것도 반환하지 않는 메소드 1개가 만들어진다.
    */

}


fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}

fun copyElements(source: Collection<Int>, target: MutableCollection<Int>) {
    source.forEach {
        target.add(it)
    }
}

fun main(args: Array<String>) {
    var isNull: String? = "is not null"
    println(isNull?.let { notNullMethod(it) })

    showProgress_274(100)

    val b: Byte = 1 // 상수 값은 적절한 타입으로 해석된다.
    val l = b + 1L // 산술 연산이 오버로드 돼 있어 Byte 와 Long 을 인자로 받을 수 있다.
    premetiveTypeCast(42) // 인자를 Long 타입으로 인식한다.


//    val company: Person_212? = null
//    val address = company ?: fail("No address")
//    println(address)

    val source: Collection<Int> = arrayListOf(3, 5, 7)
    val target: MutableCollection<Int> = arrayListOf(1)
    println("target before: $target")
    /*
    copyElements(source, target)
    // 원본 target 이 변했다. 왜 변했나? target 변수는 원본 컬렉션의 주소 값을 갖고 있고, 파라미터에 원본의 주소 값을 넘겨주었으니 함수 안에서 원본의 주소 값을 가지고 작업을 하면 원본이 그대로 변하게 되는 것.
    println("target after: $target")
     */
    // 원본 target 이 변하지 않으려면?
    copyElements(source, target.toMutableList()) // 해당 컬렉션의 모든 원소를 채워서 새로운 컬렉션을 반환한다.
    println("target after: $target")



}
