/*
    코틀린의 타입 시스템
     자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는데 도움이 되는 몇가지 특성을 새로 제공한다.
      널이 될 수 있는 타입과 읽기 전용 컬렉션이 있다.
      또한 코틀린은 자바 타입 시스템에서 불필요하거나 문제가 되던 부분을 제거했다.
       배열 지원이 그런 예에 속한다.

    널 가능성 Nullablility
     널 가능성은 NullPointerException(NPE) 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
     코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 하나 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.
     널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 컴파일 시 미리 감ㅈ미해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

    널이 될 수 있는 타입
     널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null 을 허용하게 만드는 방법이다.
     기본적으로 모든 타입은 널이 될 수 없는 타입이다. 하지만 타입 뒤에 ? 를 붙이면 널이 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.
     널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.
      예를 들어
       널이 될 수 있는 변수에 대해 변수.메소드() 처럼 메소드를 직접 호출할 수는 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입 변수에 대입할 수 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
     그렇다면 널이 될 수 있는 타입으로 뭘 할 수 있을까?
      가장 중요한 일은 null 과 비교하는 것이다.
       null 과 비교하고 나면 컴파일러는 그 사실을 기억하고 null 이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입틔 값처럼 사용할 수 있다.


    타입의 의미
     타입은 분류(classification)로 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

    NullPointerException 오류를 다루는 방법
     자바에도 NPE 문제를 해결하는데 도움을 주는 도구가 있다.
      @Nullable 이나 @NotNull 애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시한다.
      하지만 자바 컴파일 절차의 일부가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다.
     이 문제를 해결하는 다른 방법은 null 값을 코드에서 절대로 쓰지 않는 것이다.
      null 대신 자바 8에 도입된 Optional 타입 등의 null 을 감싸는 특별한 래퍼 타입을 활용할 수 있다.
       Optional 은 어떤 값이 정의되거나 정의되지 않을 수 있음을 표시하는 타입이다.
       이런 해법에는 몇가지 단점이 있다.
        코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 선응이 저하되며 전체 에코 시스템에서 일관성있게 활용하기 어렵다.
        Optional 을 사용하더라도 JDK 메소드나 안드로이드 프레임워크, 다른 서드파티 라이브러리 등에서 반환되는 null을 처리해야 한다.

    코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.
     실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
     널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
     모든 검사는 컴파일 시점에 수행된다. 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는데 별도의 실행 시점 부가 비용이 들지 않는다.

    널 가능성을 다루기 위해 사용할 수 있는 도구가 if 검사만 있을까?
     그렇지 않다. 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

    안전한 호출 연산자 ?.
     코틀린이 제공하는 가장 유용한 도구 중 하나가 안전한 호출 연산자인 ?. 이다.
     ?. 은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
      호출하려는 값이
       null 이 아니면 일반 메소드 호출처럼 동작한다.
       null 이면 이 호출을 무시하고 null 이 결과값이 된다.
     안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 사실을 기억.
     프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

    엘비스 연산자 ?:
     코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다.
     엘비스 연산자 ?: 는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다.
      좌항 값이
       null 이 아니면 좌항 값을 결과로 한다.
       null 이면 우항 값을 결과로 한다.
     엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비하는 값을 지정하는 경우도 많다.
     코틀린에서는 return 이나 throw 등의 연산도 식이다.
      따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.
       이런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.
       이런 패턴은 함수의 전제 조건(precondition)을 검사하는 경우 특히 유용하다.

     안전한 캐스트 as?
      타입 캐스트시 as 로 지정한 타입으로 바꿀 수 없으면 ClassCastException 이 발생한다.
      as? 연산자는 타입 캐스트시
       대상 타입으로 변환할 수 있으면 캐스트한다.
       대상 타입으로 변환할 수 없으면 null을 반환한다.
      안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

    널 아님 단언 !!
     널 아님 단언(not-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구다.
     !!를 사용하면 어떤 값이든 강제로 널이 될 수 없는 타입으로 바꿀 수 있다.
      실제 널에 대해 !!를 적용하면 NPE 가 발생한다.
     !!는 컴파일러에게 "나는 이 값이 null 이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다" 라고 말하는 것이다.
     !!를 한줄에 여러번 사용하는 일을 피하라.
      !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄이었는지에 대한 정보는 들어있으나 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

    널이 될 수 있는 타입의 값을 널이 아닌 값만 인자로 받는 함수에 넘기려면 어떻게 해야할까?
     그런 호출은 안전하지 않기 때문에 허용하지 않는다.
     코틀린 언어는 이런 경우 특별한 지원을 제공하지 않지만 표준 라이브러리에 도움이 될 수 있는 함수가 있다.
      그 함수는 let 이다.

    let
     let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.
     let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 될 수 없는 값만 인자로 받는 함수에 넘기는 경우다.
     자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
     안전한 호출 구문과 같이 사용해 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에게 전달할 수 있다.
     foo?.let { }
      foo 가 널이 아니면 람다를 실행한다. 이때 람다 안에서 it 은 foo 객체가 된다.
      foo 가 널이면 아무일도 일어나지 않는다.

    나중에 초기화할 프로퍼티
     val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다.
     코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.
      프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 초기화해야 한다.
      초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수밖에 없다.
       하지만 널이 될 수 있는 타입을 사용하면 프로퍼티 접근에 널 검사를 넣거나 !! 연산자를 써야 한다.
     이를 해결하기 위해 프로퍼티에 lateinit 을 써서 나중에 초기화할 수 있다.
      나중에 초기화하는 프로퍼티는 항상 var 여야 한다.
      나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다.

    널이 될 수 있는 타입 확장
     널이 될 수 있는 타입에 대한 확장 함수를 정의하면 널이 될 수 있는 값에 대해 안전한 호출 연산 없이 확장 함수를 호출할 수 있다.
      널이 될 수 있는 타입에 대한 확장 함수 내부에서 this 는 널이 될 수 있어 명시적으로 널 여부를 검사해야 한다.
       자바에서는 메소드 안의 this 는 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다.
        자바에서는 수신 객체가 널이었다면 NPE 가 발생해 메소드 안으로 들어가지를 못한다. 따라서 정상 실행됐다면 그 메소드 안에서 this 는 항상 널이 아니게 된다.
      let 함수도 널이 될 수 있는 값에 대해 호출할 수 있지만 let 은 this 가 널인지 검사하지 않는다. 따라서 널인지 검사하고 싶다면 안전한 호출 연산자를 같이 사용해야 한다.

    확장 함수를 정의할 때
     널이 될 수 있는 타입에 대해 정의할지 여부를 고민할 필요가 있다.
      처음에는 널이 될 수 없는 타입에 대한 확장 함수를 정의하라.
      나중에 널이 될 수 있는 타입에 대해 그 함수를 호출했다는 사실을 깨닫는다면 그 함수 안에서 널을 제대로 처리하기만 해주면 된다.
      확장 함수를 통해 널 검사를 함수 안으로 옮길 수 있다.

    타입 파라미터의 널 가능성
     코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
      따라서 타입 파라미터 T 를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T 가 널이 될 수 있는 타입이다.
      타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외다.
     타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한(upper bound)을 지정해야 한다.
      fun <T:Any> printHashCode(t: T) { ... } 이렇게 T:Any 이렇게 작성한 것을 타입 상한이라 하며 타입 파라미터가 널이 될 수없는 Any 타입만을 받도록 지정한다.

    플랫폼 타입
     코틀린은 애노테이션이 붙은 자바 타입을 애노테이션에 따라 널이 될 수 있는 타입이나 널이 될 수 없는 타입으로 취급한다.
      JSR-305 표준, 안드로이드, 젯브레인스 도구들이 지원하는 애노테이션 등이 코틀린이 이해할 수 있는 널 가능성 애노테이션들이다.
      이런 널 가능성 애노테이션이 소스 코드에 없는 경우 자바의 타입은 플랫폼 타입이 된다.
     플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
     널이 될 수 있는 타입으로 처리해도 되고, 널이 될 수 없는 타입으로 처리해도 된다.
     이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.
     컴파일러는 모든 연산을 허용한다.
      코틀린은 보통 널이 될 수 없는 타입에 널 검사를 하면 경고를 표시해주지만 플랫폼 타입의 값에 널 검사를 중복 수행해도 아무 경고를 표시하지 않는다.
     모든 자바 타입을 널이 될 수 있는 타입으로 다루면 널 검사 비용이 너무 커지게 되어 플랫폼 타입이 도입됐다.
     코틀린에서 플랫폼 타입을 선언할 수는 없다. 자바 코드에서 가져온 타입만 플랫폼 타입이 된다.
      IDE 나 컴파일러 오류 메시지에서는 플랫폼 타입을 볼 수 있다.
     플랫폼 타입의 표기는 타입! 로 표기한다.


    코틀린과 자바를 혼합한 클래스 계층을 선언할 때 빠지기 쉬운 함정
    상속
     코틀린에서 자바 메소드를 오버라이드할 때 메소드의 파라미터와 반환 타입의 널 여부를 결정해야한다.
      자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.

    널 가능성 관련 지식은 코틀린이 자바의 박스 타입을 처리하는 방법을 이해할 때 중요한 역할을 한다.

    코틀린의 원시 타입
     자바는 원시 타입과 참조 타입을 구분한다.
      원시 타입의 변수에는 값이 직접 들어간다.
       원시 타입의 값은 결코 널이 될 수 없다.
      참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.

     코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.
      코틀린은 항상 객체로 표현하는 것일까? 그렇지 않다.
      실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.
       대부분의 경우 변수, 프로퍼티, 파라미터, 반환 타입 등 코틀린의 Int 타입은 자바 int 타입으로 컴파일 된다.
        이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우 뿐이다.

    널이 될 수 있는 원시 타입
     널 참조는 자바의 참조 타입 변수에만 대입할 수 있으므로, 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 자바의 래퍼 타입으로 컴파일 된다.
     제네릭 클래스의 타입인자로 원시타입을 넘기면 그 타입에 대한 박스타입을 사용한다.
      JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다.

    숫자 변환
     코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다.
     코틀린 한 타입의 숫자를 다른 타입의 숫자로 변환하지 않는다.
      원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.
     코틀린은 모든 원시 타입에 대한 변환 함수를 제공한다.
      코틀린은 개발자의 혼란을 피하기 위해 타입 변환을 명시하기로 결정했다.
      코드에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.
     숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다.
      숫자 리터럴을 타입이 알려진 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.
     산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드 돼 있다.
     코틀린 산술 연산자에서도 자바와 똑같이 숫자 연산시 값 넘침(overflow)이 발생할 수 있다.
      값 넘침을 검사하느라 추가 비용을 들이지 않는다.

*/

/*
    검색
     1. 자바8 Optional 타입
     2. 의존 관게 주입 (DI)
     3. 동적 디스패치, 정적 디스패치
      디스패치
       프로그램이 어떤 메소드를 호출할 것인가를 결정하여 그것을 실행하는 과정을 말한다.
      정적 디스패치
       컴파일 시점에 컴파일러가 어떤 클래스의 메소드를 실행해야하는지 알고 바이트코드로 남는다.
      동적 디스패치
       컴파일 시점에선 어떤 메소드를 호출하는지 모르고, 추상 타입의 메소드를 호출하는 것만 알고 있다.
       런타임 시점에 할당된 객체의 타입을 보고 메소드를 실행함.
*/
package sixth



fun notNullMethod(s: String) = "this is not null"

fun premetiveTypeCast(l: Long) = println(l)

class OverrdieJava: Java220325_272() {
    // null 이 불가능한 String 파라미터로 오버라이드함.
    override fun process(value: String) {}
}

fun showProgress_274(progress: Int) {
    // coerceIn 은 지정된 범위내에 값이 들어있는지 확인하는 표준 라이브러리 함수다.
    val percent = progress.coerceIn(0, 100)
    println("We're $percent% done!")
}

fun main(args: Array<String>) {
    var isNull: String? = "is not null"
    println(isNull?.let { notNullMethod(it) })

    showProgress_274(100)

    val b: Byte = 1 // 상수 값은 적절한 타입으로 해석된다.
    val l = b + 1L // 산술 연산이 오버로드 돼 있어 Byte 와 Long 을 인자로 받을 수 있다.
    premetiveTypeCast(42) // 인자를 Long 타입으로 인식한다.

}
