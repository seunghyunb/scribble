/*
    코틀린의 타입 시스템
     자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는데 도움이 되는 몇가지 특성을 새로 제공한다.
      널이 될 수 있는 타입과 읽기 전용 컬렉션이 있다.
      또한 코틀린은 자바 타입 시스템에서 불필요하거나 문제가 되던 부분을 제거했다.
       배열 지원이 그런 예에 속한다.

    널 가능성 Nullablility
     널 가능성은 NullPointerException(NPE) 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
     코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 하나 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.
     널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 컴파일 시 미리 감ㅈ미해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

    널이 될 수 있는 타입
     널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null 을 허용하게 만드는 방법이다.
     기본적으로 모든 타입은 널이 될 수 없는 타입이다. 하지만 타입 뒤에 ? 를 붙이면 널이 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.
     널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.
      예를 들어
       널이 될 수 있는 변수에 대해 변수.메소드() 처럼 메소드를 직접 호출할 수는 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입 변수에 대입할 수 없다.
       널이 될 수 있는 타입을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
     그렇다면 널이 될 수 있는 타입으로 뭘 할 수 있을까?
      가장 중요한 일은 null 과 비교하는 것이다.
       null 과 비교하고 나면 컴파일러는 그 사실을 기억하고 null 이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입틔 값처럼 사용할 수 있다.


    타입의 의미
     타입은 분류(classification)로 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

    NullPointerException 오류를 다루는 방법
     자바에도 NPE 문제를 해결하는데 도움을 주는 도구가 있다.
      @Nullable 이나 @NotNull 애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시한다.
      하지만 자바 컴파일 절차의 일부가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다.
     이 문제를 해결하는 다른 방법은 null 값을 코드에서 절대로 쓰지 않는 것이다.
      null 대신 자바 8에 도입된 Optional 타입 등의 null 을 감싸는 특별한 래퍼 타입을 활용할 수 있다.
       Optional 은 어떤 값이 정의되거나 정의되지 않을 수 있음을 표시하는 타입이다.
       이런 해법에는 몇가지 단점이 있다.
        코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 선응이 저하되며 전체 에코 시스템에서 일관성있게 활용하기 어렵다.
        Optional 을 사용하더라도 JDK 메소드나 안드로이드 프레임워크, 다른 서드파티 라이브러리 등에서 반환되는 null을 처리해야 한다.

    코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.
     실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
     널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
     모든 검사는 컴파일 시점에 수행된다. 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는데 별도의 실행 시점 부가 비용이 들지 않는다.

    널 가능성을 다루기 위해 사용할 수 있는 도구가 if 검사만 있을까?
     그렇지 않다. 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

    안전한 호출 연산자 ?.
     코틀린이 제공하는 가장 유용한 도구 중 하나가 안전한 호출 연산자인 ?. 이다.
     ?. 은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
      호출하려는 값이
       null 이 아니면 일반 메소드 호출처럼 동작한다.
       null 이면 이 호출을 무시하고 null 이 결과값이 된다.
     안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 사실을 기억.
     프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

    엘비스 연산자 ?:
     코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다.
     엘비스 연산자 ?: 는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다.
      좌항 값이
       null 이 아니면 좌항 값을 결과로 한다.
       null 이면 우항 값을 결과로 한다.
     엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비하는 값을 지정하는 경우도 많다.
     코틀린에서는 return 이나 throw 등의 연산도 식이다.
      따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.
       이런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.
       이런 패턴은 함수의 전제 조건(precondition)을 검사하는 경우 특히 유용하다.

     안전한 캐스트 as?
      타입 캐스트시 as 로 지정한 타입으로 바꿀 수 없으면 ClassCastException 이 발생한다.
      as? 연산자는 타입 캐스트시
       대상 타입으로 변환할 수 있으면 캐스트한다.
       대상 타입으로 변환할 수 없으면 null을 반환한다.
      안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

    널 아님 단언 !!
     널 아님 단언(not-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구다.
     !!를 사용하면 어떤 값이든 강제로 널이 될 수 없는 타입으로 바꿀 수 있다.
      실제 널에 대해 !!를 적용하면 NPE 가 발생한다.
     !!는 컴파일러에게 "나는 이 값이 null 이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다" 라고 말하는 것이다.
     !!를 한줄에 여러번 사용하는 일을 피하라.
      !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄이었는지에 대한 정보는 들어있으나 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

    널이 될 수 있는 타입의 값을 널이 아닌 값만 인자로 받는 함수에 넘기려면 어떻게 해야할까?
     그런 호출은 안전하지 않기 때문에 허용하지 않는다.
     코틀린 언어는 이런 경우 특별한 지원을 제공하지 않지만 표준 라이브러리에 도움이 될 수 있는 함수가 있다.
      그 함수는 let 이다.

    let
     let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.
     let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 될 수 없는 값만 인자로 받는 함수에 넘기는 경우다.
     자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
     안전한 호출 구문과 같이 사용해 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에게 전달할 수 있다.
     foo?.let { }
      foo 가 널이 아니면 람다를 실행한다. 이때 람다 안에서 it 은 foo 객체가 된다.
      foo 가 널이면 아무일도 일어나지 않는다.

    나중에 초기화할 프로퍼티
     val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다.
     코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.
      프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 초기화해야 한다.
      초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수밖에 없다.
       하지만 널이 될 수 있는 타입을 사용하면 프로퍼티 접근에 널 검사를 넣거나 !! 연산자를 써야 한다.
     이를 해결하기 위해 프로퍼티에 lateinit 을 써서 나중에 초기화할 수 있다.
      나중에 초기화하는 프로퍼티는 항상 var 여야 한다.
      나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다.

    널이 될 수 있는 타입 확장
     널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
     메소드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해준다.
      이런 처리는 확장 함수에서만 가능하다. 일반 멤버 호출은 객체 인스턴스를 통해 디스패치되므로 그 인스턴스가 널인지 여부를 검사하지 않는다.
     널이 될 수 있는 타입의 확장 함수는 안전한 호출 없이도 호출 가능하다.



*/
package sixth


/*
    검색
     1. 자바8 Optional 타입
     2. 의존 관게 주입 (DI)
     3. 동적 디스패치, 정적 디스패치
      디스패치
       프로그램이 어떤 메소드를 호출할 것인가를 결정하여 그것을 실행하는 과정을 말한다.
      정적 디스패치
       컴파일 시점에 컴파일러가 어떤 클래스의 메소드를 실행해야하는지 알고 바이트코드로 남는다.
      동적 디스패치
       컴파일 시점에선 어떤 메소드를 호출하는지 모르고, 추상 타입의 메소드를 호출하는 것만 알고 있다.
       런타임 시점에 할당된 객체의 타입을 보고 메소드를 실행함.
*/

fun notNullMethod(s: String) = "this is not null"

fun main(args: Array<String>) {
    var isNull: String? = "is not null"
    println(isNull?.let { notNullMethod(it) })


}
